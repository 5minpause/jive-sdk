/*
 * Copyright 2013 Jive Software
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

/**
 * Library for manipulating external stream instances.
 */

var q = require('q');
var util = require('util');
var jive = require('../api');
var instances = require('./instances');
var pusher = require('./dataPusher');

var extstreams = Object.create(instances);
module.exports = extstreams;

extstreams.getCollection = function() {
    return "extstreamInstance";
};

extstreams.pushActivity = function ( tileInstance, activity) {
    return pusher.pushActivity(tileInstance, activity);
};

var pushComment = function ( tileInstance, comment, commentURL) {
    return pusher.pushComment(tileInstance, commentURL, comment);
};

/**
 * Create a comment in Jive on an activity that was generated by an external stream.
 *
 * @param activity - activity object returned from jive. For example, an object returned in the promise by extstreams.pushActivity method
 * @param comment - comment JSON, see https://developers.jivesoftware.com/api/rest/CommentEntity.html
 *
 * @returns a promise that resolves with a response object. response.entity is the created comment that is returned from Jive
 */
extstreams.commentOnActivity = function(activity, comment ) {
    if (!(activity && activity.resources && activity.resources.comments && activity.resources.comments.ref)
        || !activity.parent) {

        throw new Error('Error in jive.extstreams.commentOnActivity: input activity is not a valid Jive object.' +
            'It is missing the resources.comments.ref field or parent field.');
    }
    var commentsURL = activity.resources.comments.ref;
    var parentInstanceURL = activity.parent + '/activities';

    return extstreams.findByURL(parentInstanceURL).then(function(extstream) {
        if (!comment.externalID){
            comment.externalID = extstream.name + '_' + 'comment' + '_' + String(new Date().getTime());
            jive.logger.warn(util.format('No externalID field given when creating new comment. Assigning ID %s', comment.externalID ));
        }
        return pushComment(extstream, comment, commentsURL);
    });

};

/**
 * Create a comment on an activity using this endpoint---
 * http://mycomany.jiveon.com/api/jivelinks/v1/extstreams/1234/extactivities/{externalActivityID}/comments
 * @param externalActivityID
 * @param extstream
 * @param comment
 */
extstreams.commentOnActivityByExternalID = function(extstream, externalActivityID, comment) {
    var dataURL = extstream['url'];
    var commentsURL = dataURL.replace(/activities$/, 'extactivities/') + externalActivityID + '/comments';
    if (!comment.externalID){
        comment.externalID = extstream.name + '_' + 'comment' + '_' + String(new Date().getTime());
        jive.logger.warn(util.format('No externalID field given when creating new comment. Assigning ID %s', comment.externalID ));
    }
    return pushComment(extstream, comment, commentsURL);
}

//Change default options here
var DEFAULT_OPTS = {
    commentSourceType: "ALL"
};

/**
 *
 * Options for the following methods look like:
 * var opts = {
 *      "fieldList": ["content", "parent", "resources" ], // list of fields to be returned on Jive entity
 *      "itemsPerPage": 100,              // for paginated requests, the no. of items to return per request
 *      "commentSourceType": "JIVE",     // Must be "JIVE" or "EXTERNAL" or "ALL". Defaults to "ALL"
 *      "publishedAfter": 1367968760257  // Get comments that were created after this time only
 * }
 */
/**
 * Get all the comments in Jive for a given activity object.
 *
 * @param activity - activity object
 * @param opts - JSON describing options for retrieving content from Jive. See above documentation.
 * @returns a promise that resolves to a response. response.entity is the list of comments. See  See https://developers.jivesoftware.com/api/rest/index.html#lists
 */
extstreams.fetchCommentsOnActivity = function(activity, opts) {
    opts = opts || DEFAULT_OPTS;
    if (!(activity && activity.resources && activity.resources.comments && activity.resources.comments.ref)
        || !activity.parent) {
        throw new Error('Error in jive.extstreams.fetchCommentsOnActivity: ' +
            'input activity is not a valid Jive object. It is missing the resources.comments.ref field or parent field.');
    }

    var commentsURL = activity.resources.comments.ref;

    commentsURL += buildQueryString(opts['fieldList'], opts['itemsPerPage'], opts['commentSourceType']);

    var parentInstanceURL = activity.parent + '/activities';
    return extstreams.findByURL(parentInstanceURL).then( function(extstream) {
        return pusher.getPaginated(extstream, commentsURL );
    }).then(function(response){
            if (response.entity && response.entity.list) {
                response.entity.list = filterComments(response.entity.list, opts['commentSourceType'], opts['publishedAfter']);
            }
            return response;
        });
};

/**
 * Get all comments in Jive for ALL activity of the given external stream
 * @param extstream - an external stream object from the jive-sdk
 * @param opts - JSON describing options for retrieving content from Jive. See above documentation.
 * @returns a promise that resolves to a response. response.entity is the list of comments. See  See https://developers.jivesoftware.com/api/rest/index.html#lists
 */
extstreams.fetchAllCommentsForExtstream = function(extstream, opts) {

    opts = opts || DEFAULT_OPTS;

    var dataURL = extstream['url'];
    var commentsURL = commentsUrlFromDataUrl(dataURL);

    commentsURL += buildQueryString(opts['fieldList'], opts['itemsPerPage'], opts['commentSourceType']);

    return pusher.getPaginated(extstream, commentsURL).then(function(response) {

        if (response.entity && response.entity.list) {
            response.entity.list = filterComments(response.entity.list, opts['commentSourceType'], opts['publishedAfter']);
        }
        return response;
    });

};

function buildQueryString(optionalFieldList, optionalItemsPerPage, commentSourceType) {
    var queryStr = '';
    if (optionalFieldList || optionalItemsPerPage || (commentSourceType && commentSourceType.toUpperCase() === 'JIVE')) {
        queryStr += '?';

        var q = false;
        if (optionalFieldList) {
            if (optionalFieldList.indexOf('externalID') < 0) { //Must return the externalID to be able to filter properly by comment source
                optionalFieldList.push('externalID');
            }
            if (optionalFieldList.indexOf('published') < 0) { //Need publish date for filtering
                optionalFieldList.push('published');
            }
            queryStr +=  'fields=' + encodeURIComponent(optionalFieldList.join(','));
            q = true;
        }
        if (optionalItemsPerPage) {
            queryStr += (q ? '&' : '') + 'count=' + optionalItemsPerPage;
            q = true;
        }
        if (commentSourceType && commentSourceType.toUpperCase() === 'JIVE') {
            queryStr += (q ? '&' : '') + 'filter=omitExternal'; //For efficiency add filter that omits external comments
            q = true;
        }
    }

    return queryStr;

}

//Sort of a hack to build the comments URL, because we are not storing the "resources" JSON from a Jive external stream object currently
function commentsUrlFromDataUrl(dataURL) {
     return dataURL.slice(0, dataURL.indexOf('activities')) + 'comments';
}

//Helper to filter comments based on whether the externalID field is present
function filterComments(list, commentSourceType, publishedAfter) {
    if (commentSourceType && commentSourceType.toUpperCase() != 'ALL') {

        if (commentSourceType.toUpperCase() == 'JIVE') {
            list = list.filter(function(comment) {
                return comment.externalID == undefined;
            }) ;
        }
        else if (commentSourceType.toUpperCase() == 'EXTERNAL') {
            list = list.filter(function(comment) {
                return comment.externalID != undefined;
            }) ;
        }
    }

    if (publishedAfter) {
        list = list.filter(function(comment) {
           var published = new Date(comment['published']);
           if (isNaN(published.getTime())) {
               return true;
           }
           return published.getTime() > publishedAfter;
        });
    }

    return list;
}